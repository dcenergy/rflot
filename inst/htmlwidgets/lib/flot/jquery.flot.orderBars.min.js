/*!
 * Flot plugin to order bars side by side. This is improved version of Benjamin BUFFET work
 * originally from http://en.benjaminbuffet.com/labs/flot/.
 * 
 * Released under the MIT license by Przemyslaw Koltermann, 12-Feb-2013.
 *
 * This plugin is an alpha version.
 *
 * To activate the plugin you must specify the parameter "order" for the specific serie :
 *
 *  $.plot($("#placeholder"), [{ data: [ ... ], bars :{ order = null or integer }])
 *
 * If 2 series have the same order param, they are displayed in the same position;
 *
 * The plugin adjust the point by adding a value depanding of the barwidth
 * Exemple for 3 series (barwidth : 0.1) :
 *
 *          first bar décalage : -0.15
 *          second bar décalage : -0.05
 *          third bar décalage : 0.05
 *
 */
(function(b){function c(p){var j;var w;var g=new Array();var z=new Array();var A;var x;var m=1;var h=false;function d(H,F,G){var D=null;if(t(F)){k(F);y(H);u(H);v(F);if(w>=2){var C=q(F);var I=0;var E=i();if(l(C)){I=-1*(n(j,C-1,Math.floor(w/2)-1))-E}else{I=n(j,Math.ceil(w/2),C-2)+E+x*2}D=e(G,F,I);G.points=D}else{if(w==1){var E=-1*i();D=e(G,F,E);G.points=D}}}return D}function t(C){return C.bars!=null&&C.bars.show&&C.bars.order!=null}function y(F){var D=h?F.getPlaceholder().innerHeight():F.getPlaceholder().innerWidth();var E=h?B(F.getData(),1):B(F.getData(),0);var C=E[1]-E[0];m=C/D}function B(D,F){var E=new Array();for(var C=0;C<D.length;C++){E[0]=D[C].data[0][F];E[1]=D[C].data[D[C].data.length-1][F]}if(typeof E[0]=="string"){E[0]=0;E[1]=D[0].data.length-1}return E}function u(C){j=f(C.getData());w=j.length}function f(D){var E=new Array();for(var C=0;C<D.length;C++){if(D[C].bars.order!=null&&D[C].bars.show){E.push(D[C])}}return s(E)}function s(F){var G=F.length;do{for(var E=0;E<G-1;E++){if(F[E].bars.order>F[E+1].bars.order){var D=F[E];F[E]=F[E+1];F[E+1]=D}else{if(F[E].bars.order==F[E+1].bars.order){var C;if(typeof(F[E].sameSeriesArrayIndex)!="undefined"){C=F[E].sameSeriesArrayIndex;F[E+1].sameSeriesArrayIndex=C;z[C].push(F[E+1]);z[C].sort(o);F[E]=z[C][0];r(F,E+1)}else{if(typeof(F[E+1].sameSeriesArrayIndex)!="undefined"){C=F[E+1].sameSeriesArrayIndex;F[E].sameSeriesArrayIndex=C;z[C].push(F[E]);z[C].sort(o);F[E]=z[C][0];r(F,E+1)}else{C=z.length;z[C]=new Array();F[E].sameSeriesArrayIndex=C;F[E+1].sameSeriesArrayIndex=C;z[C].push(F[E]);z[C].push(F[E+1]);z[C].sort(o);F[E]=z[C][0];r(F,E+1)}}E--;G--}}}G=G-1}while(G>1);for(var E=0;E<F.length;E++){if(F[E].sameSeriesArrayIndex){g[F[E].sameSeriesArrayIndex]=E}}return F}function o(E,D){var C=E.bars.barWidth?E.bars.barWidth:1;var F=D.bars.barWidth?D.bars.barWidth:1;return((C<F)?-1:((C>F)?1:0))}function r(C,F,E){var D=C.slice((E||F)+1||C.length);C.length=F<0?C.length+F:F;C.push.apply(C,D);return C}function v(C){A=typeof C.bars.lineWidth==="number"?C.bars.lineWidth:2;x=A*m}function k(C){if(C.bars.horizontal){h=true}}function q(E){var D=z;var F=0;if(E.sameSeriesArrayIndex){F=g[E.sameSeriesArrayIndex]}else{for(var C=0;C<j.length;++C){if(E==j[C]){F=C;break}}}return F+1}function i(){var C=0;if(w%2!=0){C=(j[Math.floor(w/2)].bars.barWidth)/2}return C}function l(C){return C<=Math.ceil(w/2)}function n(F,G,D){var C=0;for(var E=G;E<=D;E++){C+=F[E].bars.barWidth+x*2}return C}function e(H,G,C){var I=H.pointsize;var F=H.points;var D=0;for(var E=h?1:0;E<F.length;E+=I){F[E]+=C;G.data[D][3]=F[E];D++}return F}p.hooks.processDatapoints.push(d)}var a={series:{bars:{order:null}}};b.plot.plugins.push({init:c,options:a,name:"orderBars",version:"0.2"})})(jQuery);